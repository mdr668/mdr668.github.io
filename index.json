[{"categories":null,"content":"lldbtrace链接 https://github.com/yangyss/lldb-trace ","date":"2023-04-27","objectID":"/%E4%BD%BF%E7%94%A8-lldbtrace-%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"使用 LLDBTrace 还原算法","uri":"/%E4%BD%BF%E7%94%A8-lldbtrace-%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"首先利用 lldbtrace 处理一个BUG 有个经过 VMP 加固的结果一直不符合预期,大概定位一下位置 memset(dest,0,0x10000); ByteToHexStr(dvChr,dest,dvChrLen); printf(\"进入前:%s\\n\",dest); byteTurn(dvChr, dvChrLen, 0x5);//字节翻转加密 memset(dest2,0,0x10000); ByteToHexStr(dvChr,dest,dvChrLen); printf(\"进入后:%s\\n\",dest); byteTurn函数的功能是对字节分别进行翻转,并加上一个值 //字节按位翻转 并加减随机值 void byteTurn(uint8_t *lpBuf,int lpLen,int seed){ for (int i = 0; i \u003c lpLen; i++) { uint8_t byte= lpBuf[i]; lpBuf[i] = (((byte \u003c\u003c 4) | (byte \u003e\u003e 4)) + seed) \u0026 0xff; } } 在 byteTurn 函数前后分别打印 进入前: 06 9c e7 0e 9c a6 d1 6d bd c8 77 a5 d1 68 bd cf WASM值: 65 fe 03 e5 fe ff 02 db 00 01 7c ff 02 8b 00 01 正 常 值: 65 ce 83 e5 ce 6f 22 db e0 91 7c 5f 22 8b e0 01 这里发现,部分字节经过翻转加密之后得出的结果和正常结果不一致 对源码进行下断点调试,发现第一个BUG 这里汇编的大概意思是,取 var15 和 -4 进行比较,如果 var15 \u003c -4 的话就跳转label14 但是在对照解释器时发现,两个值都被转成无符号int32进行比较: case I32LtS: c = (uint32_t) a \u003c (uint32_t) b; break; 在无符号int32中, -4 会被转成 0xFFFFFFFC (4294967292),然后 var15 就会恒小于 0xFFFFFFFC的,这里显然是不合理的,所以这里应该改为有符号的比较 case I32LtS: c = (int32_t)a \u003c (int32_t)b; break; 查找字节转换失败的原因 因为VMP解释器中流转非常复杂,进行断点调试难度还是比较大的,所以我这边采用使用lldbtrace先把大概的流程trace出来 在trace之前需要先确定一下 dvChr 的内存地址,这样比较容易定位一些 (lldb) p/x dvChr (uint64_t) $16 = 0x0000000282634000 然后就可以打开trace,本来等待程序自己运行结束 但是运行了3小时,才产生了4w+行的日志,真机trace效率较低 感觉自己需要的部分应该差不多有了就结束了trace 分析trace日志 首先搜索 dvChr 的内存地址进行一个基本的定位 发现结果才40条,不符合预期 因为这个加密函数是按位操作的,尝试内存位去掉一位,搜索 28263400 这次有316条,基本接近了 简单分析一下日志,0x10026f274 这里是对内存赋值,也就是生成结果的位置 WASM值: 65 fe 03 e5 fe ff 02 db 00 01 7c ff 02 8b 00 01 符合我们的生成预期 因为第二个字节 9c =\u003e ce 时出错了, 转成 9c =\u003e fe,我们需要查看 282634001 的 0xfffffffe 是怎么生成的 尝试搜索 0xfffffffe 查看生成位置 定位到 0xfffffffe = 0xfffffff9 + 0x00000005,符合预期 继续向上查找 0xfffffff9 是怎么生成 这里可以看出 0xfffffff9 = 0xfffff9c0 | 0x0ffffff9 但是我们正常的运行逻辑应该是 0xc9 = 0xc0 | 0x09 继续查找 0x0ffffff9 的生成,最终定位在 错误原因:ldrsb（功能不变指令变为带符号8位）,所以在高位自动补了0xffffff 对应代码里的位置为 case I32Load8U: stack[m-\u003esp].value.int32 = *(int8_t*)maddr; stack[m-\u003esp].value_type = I32; break; 这里做一下修改 case I32Load8U: stack[m-\u003esp].value.int32 = (*(int8_t*)maddr) \u0026 0xff; stack[m-\u003esp].value_type = I32; break; 对应的汇编指令 ldrb(功能不变，指令变为8位) 这样子就恢复正常,解决了问题 ","date":"2023-04-27","objectID":"/%E4%BD%BF%E7%94%A8-lldbtrace-%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/:0:1","tags":null,"title":"使用 LLDBTrace 还原算法","uri":"/%E4%BD%BF%E7%94%A8-lldbtrace-%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"还原阿里WAF算法 appkey: j0m4PjXNgOX_A_ZJXjBNgJ0DRtp_VQWwEMS5DkAJUJsKPR-0r8PqOkWMrhwymjZCoyOzBW2aqkrY8Tw9Cbwyl9fMOlOMPTC7_sOho2t_mOpdhkcQrWAc8fv_EATLX5DSrlve4QlMpMZtIuTfry6bm9BLY-_E9b9Kwmha6fZHAZY= =\u003e 52cce52117575f24|14b8_d5bdfc94-fd29-4d22-8eef-c9b4af7b2db7|d330_c4857e5e-0b88-42de-9782-813d43b7cd56|m.yundun.waf.1|0002 由hook得知AES的key和iv,从trace日志中查找生成算法 key = bytes.fromhex('42 36 03 c1 b2 8a b2 3a b7 53 25 97 87 12 5b 85') iv = bytes.fromhex('31 33 61 66 75 74 74 94 b5 16 1f 92 2d 47 9c b1') KEY的生成 尝试搜索 423603c1 发现 0x423603c1b28ab23ab753259787125b85 = 0x512510d2a199a129a440368494014896 ^ 0x13131313131313131313131313131313 由hook得知 0x512510d2a199a129a440368494014896 = MD5(d5bdfc94-fd29-4d22-8eef-c9b4af7b2db7) 查找 0x13131313131313131313131313131313 的生成 dup用于把一个相同值赋值若干次 查找 w8 : 0x00000013 的生成 0x00000013 = 0x0000000d + 0x00000006 0x0000000d 和 0x00000006 是 0xfffffe6d 个位和十位 查找 w8 : 0xfffffe6d 的生成 0xfffffe6d = 0xffffff96 + 0xfffffed7 0xfffffed7 = 0x00000048 + 0xfffffe8f 0xfffffe8f = 0x00000001 + 0xfffffe8e 0xfffffe8e = 0xffffff94 + 0xfffffefa 0xfffffefa = 0xffffff84 + 0xffffff76 .... 发现是一个循环相加, 仔细看可以知道是 0x512510d2a199a129a440368494014896 的循环相加 写个简单的代码验证一下 bytearray = bytes.fromhex('512510d2a199a129a440368494014896') ret = 0 for key in bytearray: ret += int(key) print(hex(ret)) ==\u003e 0x66d 尾数 0x6d 符合预期 IV 的生成 iv = bytes.fromhex('31 33 61 66 75 74 74 94 b5 16 1f 92 2d 47 9c b1') 直接搜索 31336166 没有结果 顺位搜索后面四个字节 75747494 0x33616675747494b50000000000000000 = 0x32636365353231310000000000000000 ^ 0x010205104146a5840000000000000000 可得 0x010205104146a5840000000000000000 为固定值 未完待续… ","date":"2023-04-27","objectID":"/%E4%BD%BF%E7%94%A8-lldbtrace-%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/:0:2","tags":null,"title":"使用 LLDBTrace 还原算法","uri":"/%E4%BD%BF%E7%94%A8-lldbtrace-%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"使用前需要先指定hugo sites的路径 #!/bin/sh fileDir={{fileDir}} cdate=$(date +%Y-%m-%dT%H:%M:%S+08:00) hugo_path=\"${fileDir%????}/hugo_blogs\" pagesname=\"{{title}}\" filename={{fileName}} mweb_mediapath={{fileDir}}/media/${filename%???} #拷贝文档目录 pagespath=$hugo_path/content/posts/$pagesname if [ ! -d \"$pagespath\" ]; then mkdir \"$pagespath\" fi cp -rf \"{{filePath}}\" \"$pagespath\"/index.md sed -i \"\" -e '1 d' \"$pagespath\"/index.md sed -i \"\" -e '1 i \\ ---\\ title: '\"${pagesname}\"'\\ date: '\"${cdate}\"'\\ author:\\ name: 猫大人\\ ---\\' \"$pagespath\"/index.md #拷贝资源目录 if [ -d \"$mweb_mediapath\" ]; then mediapath=$hugo_path/content/posts/\"$pagesname\"/media/ if [ ! -d \"$mediapath\" ]; then mkdir \"$mediapath\" fi cp -rf \"$mweb_mediapath\" \"$mediapath\" fi cd $hugo_path git add . git commit -m \"pages: $pagesname\" git push ","date":"2023-04-27","objectID":"/mweb%E4%B8%8A%E9%9D%A2%E7%9A%84hugo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E8%84%9A%E6%9C%AC/:0:0","tags":null,"title":"MWeb上面的hugo一键发布脚本","uri":"/mweb%E4%B8%8A%E9%9D%A2%E7%9A%84hugo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":" 0 AUE_NULL ALL { int nosys(void); } { indirect syscall } 1 AUE_EXIT ALL { void exit(int rval) NO_SYSCALL_STUB; } 2 AUE_FORK ALL { int fork(void) NO_SYSCALL_STUB; } 3 AUE_NULL ALL { user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); } 4 AUE_NULL ALL { user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); } 5 AUE_OPEN_RWTC ALL { int open(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; } 6 AUE_CLOSE ALL { int sys_close(int fd); } 7 AUE_WAIT4 ALL { int wait4(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; } 8 AUE_NULL ALL { int enosys(void); } { old creat } 9 AUE_LINK ALL { int link(user_addr_t path, user_addr_t link); } 10 AUE_UNLINK ALL { int unlink(user_addr_t path) NO_SYSCALL_STUB; } 11 AUE_NULL ALL { int enosys(void); } { old execv } 12 AUE_CHDIR ALL { int chdir(user_addr_t path); } 13 AUE_FCHDIR ALL { int fchdir(int fd); } 14 AUE_MKNOD ALL { int mknod(user_addr_t path, int mode, int dev); } 15 AUE_CHMOD ALL { int chmod(user_addr_t path, int mode) NO_SYSCALL_STUB; } 16 AUE_CHOWN ALL { int chown(user_addr_t path, int uid, int gid); } 17 AUE_NULL ALL { int enosys(void); } { old break } 18 AUE_GETFSSTAT ALL { int getfsstat(user_addr_t buf, int bufsize, int flags); } 19 AUE_NULL ALL { int enosys(void); } { old lseek } 20 AUE_GETPID ALL { int getpid(void); } 21 AUE_NULL ALL { int enosys(void); } { old mount } 22 AUE_NULL ALL { int enosys(void); } { old umount } 23 AUE_SETUID ALL { int setuid(uid_t uid); } 24 AUE_GETUID ALL { int getuid(void); } 25 AUE_GETEUID ALL { int geteuid(void); } 26 AUE_PTRACE ALL { int ptrace(int req, pid_t pid, caddr_t addr, int data); } #if SOCKETS 27 AUE_RECVMSG ALL { int recvmsg(int s, struct msghdr *msg, int flags) NO_SYSCALL_STUB; } 28 AUE_SENDMSG ALL { int sendmsg(int s, caddr_t msg, int flags) NO_SYSCALL_STUB; } 29 AUE_RECVFROM ALL { int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, int *fromlenaddr) NO_SYSCALL_STUB; } 30 AUE_ACCEPT ALL { int accept(int s, caddr_t name, socklen_t *anamelen) NO_SYSCALL_STUB; } 31 AUE_GETPEERNAME ALL { int getpeername(int fdes, caddr_t asa, socklen_t *alen) NO_SYSCALL_STUB; } 32 AUE_GETSOCKNAME ALL { int getsockname(int fdes, caddr_t asa, socklen_t *alen) NO_SYSCALL_STUB; } #else 27 AUE_NULL ALL { int nosys(void); } 28 AUE_NULL ALL { int nosys(void); } 29 AUE_NULL ALL { int nosys(void); } 30 AUE_NULL ALL { int nosys(void); } 31 AUE_NULL ALL { int nosys(void); } 32 AUE_NULL ALL { int nosys(void); } #endif /* SOCKETS */ 33 AUE_ACCESS ALL { int access(user_addr_t path, int flags); } 34 AUE_CHFLAGS ALL { int chflags(char *path, int flags); } 35 AUE_FCHFLAGS ALL { int fchflags(int fd, int flags); } 36 AUE_SYNC ALL { int sync(void); } 37 AUE_KILL ALL { int kill(int pid, int signum, int posix) NO_SYSCALL_STUB; } 38 AUE_NULL ALL { int nosys(void); } { old stat } 39 AUE_GETPPID ALL { int getppid(void); } 40 AUE_NULL ALL { int nosys(void); } { old lstat } 41 AUE_DUP ALL { int sys_dup(u_int fd); } 42 AUE_PIPE ALL { int pipe(void); } 43 AUE_GETEGID ALL { int getegid(void); } 44 AUE_NULL ALL { int nosys(void); } { old profil } 45 AUE_NULL ALL { int nosys(void); } { old ktrace } 46 AUE_SIGACTION ALL { int sigaction(int signum, struct __sigaction *nsa, struct sigaction *osa) NO_SYSCALL_STUB; } 47 AUE_GETGID ALL { int getgid(void); } 48 AUE_SIGPROCMASK ALL { int sigprocmask(int how, user_addr_t mask, user_addr_t omask); } 49 AUE_GETLOGIN ALL { int getlogin(char *namebuf, u_int namelen) NO_SYSCALL_STUB; } 50 AUE_SETLOGIN ALL { int setlogin(char *namebuf) NO_SYSCALL_STUB; } 51 AUE_ACCT ALL { int acct(char *path); } 52 AUE_SIGPENDING ALL { int sigpending(struct sigvec *osv); } 53 AUE_SIGALTSTACK ALL { int sigaltstack(struct sigaltstack *nss, struct sigaltstack *oss) NO_SYSCALL_STUB ; } 54 AUE_IOCTL ALL { int ioctl(int fd, u_long com, caddr_t data) NO_SYSCALL_STUB; } 55 AUE_REBOOT ALL { int reboot(int opt, char *msg) NO_SYSCALL_STUB; } 56 AUE_REVOKE ALL { int revoke(char *path); } 57 AUE_SYMLINK AL","date":"2023-04-27","objectID":"/ios-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/:0:0","tags":null,"title":"iOS 系统调用号","uri":"/ios-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"},{"categories":null,"content":"其中 -n 参数表示打印特定的 probs 内容的调用。现在这样仅仅显示了调用，但是调用的信息还是不详细的。这个时候就需要使用 dtrace 的脚本获取更多的信息。 dtrace 的脚本 dtrace 的名字暗示了自己的脚本，dtrace 使用了 D 语言作为脚本语言。 首先，我们需要创建一个叫 syscall.d 文件 syscall::read:entry {printf (\"%s called read, asking for %d bytes\\n\", execname, arg2); } execname 代表了进程名字 sudo dtrace -s syscall.d sudo dtrace -n 'syscall::exit:entry { printf (\"%s called exit %s\\n\", execname ,probefunc); ustack();}' -o ~/Desktop/dtrace3.log sudo dtrace -n 'syscall::open:entry { printf(\"%s %s\", execname, copyinstr(arg0)); }' -o ~/Desktop/dtrace4.log 打印open的调用参数 sudo dtrace -n 'syscall::open:entry { printf(\"open(\\\"%s\\\", %d, %d)\\n\", copyinstr(arg0), arg1, arg2); ustack();}' 监听指定 pid 的信息 sudo dtrace -qn 'syscall::write:entry, syscall::sendto:entry /pid == $target/ { printf(\"(%d) %s %s\", pid, probefunc, copyinstr(arg1)); }' -p [PID] 跟踪ptrtace并打印堆栈 可以对抗syscall调用 dtrace -q -n 'syscall:::entry /pid == $target \u0026\u0026 probefunc == \"ptrace\"/ { ustack(); }' -p \u003cpid\u003e ","date":"2023-04-27","objectID":"/%E4%BD%BF%E7%94%A8-dtrace-%E7%BB%95%E8%BF%87-mac-%E4%B8%8A%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:0:0","tags":null,"title":"使用 dtrace 绕过 mac 上越狱检测","uri":"/%E4%BD%BF%E7%94%A8-dtrace-%E7%BB%95%E8%BF%87-mac-%E4%B8%8A%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"1、spawn - 冷启动 $ frida-trace -U -f com.apple.ExampleCode -m \"+[NSURL URLWithString:]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"2、attach - 热启动 $ frida-trace -UF -m \"+[NSURL URLWithString:]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"3、Hook类方法 $ frida-trace -UF -m \"+[NSURL URLWithString:]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"4、Hook实例方法 $ frida-trace -UF -m \"-[NSURL host]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"5、Hook类的所有方法 $ frida-trace -UF -m \"*[NSURL *]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"6、模糊Hook类的所有方法 $ frida-trace -UF -m \"*[*service* *]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"7、模糊Hook所有类的特定方法 $ frida-trace -UF -m \"*[* *sign*]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"8、模糊Hook所有类的特定方法并忽略大小写 假设我们要hook所有类中包含getSign或getsign关键词的方法 $ frida-trace -UF -m \"*[* get?ign]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"9、模糊Hook所有类的特定方法并排除viewDidLoad方法 $ frida-trace -UF -m \"*[DetailViewController *]\" -M \"-[DetailViewController viewDidLoad]\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"10、Hook某个动态库 $ frida-trace -UF -I \"libcommonCrypto*\" ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"11、Hook get或post的接口地址 $ frida-trace -UF -m \"+[NSURL URLWithString:]\" js代码如下： { onEnter(log, args, state) { var args2 = new ObjC.Object(args[2]); log(`-[NSURL URLWithString:${args2}]`); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:11:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"12、Hook post的body $ frida-trace -UF -m \"-[NSMutableURLRequest setHTTPBody:]\" js代码如下： { onEnter(log, args, state) { var args2 = new ObjC.Object(args[2]); log(`-[NSMutableURLRequest setHTTPBody:${args2.bytes().readUtf8String(args2.length())}]`); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:12:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"13、Hook即将显示页面 $ frida-trace -UF -m \"-[UINavigationController pushViewController:animated:]\" -m \"-[UIViewController presentViewController:animated:completion:]\" pushViewController:animated:方法的js代码如下： { onEnter(log, args, state) { var args2 = new ObjC.Object(args[2]); log(`-[UINavigationController pushViewController:${args2.$className} animated:${args[3]}]`); }, onLeave(log, retval, state) { } } presentViewController:animated:completion:方法对应的js代码如下： { onEnter(log, args, state) { var args2 = new ObjC.Object(args[2]); log(`-[UIViewController presentViewController:${args2.$className} animated:${args[3]} completion:${args[4]}]`); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:13:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"14、Hook MD5函数 $ frida-trace -UF -i \"CC_MD5\" js代码如下： { onEnter(log, args, state) { this.args0 = args[0]; // 入参 this.args2 = args[2]; // 返回值指针 }, onLeave(log, retval, state) { var ByteArray = Memory.readByteArray(this.args2, 16); var uint8Array = new Uint8Array(ByteArray); var str = \"\"; for(var i = 0; i \u003c uint8Array.length; i++) { var hextemp = (uint8Array[i].toString(16)) if(hextemp.length == 1){ hextemp = \"0\" + hextemp } str += hextemp; } log(`CC_MD5(${this.args0.readUtf8String()})`); // 入参 log(`CC_MD5()=${str}=`); // 返回值 } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:14:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"15、Hook Base64编码方法 $ frida-trace -UF -m \"-[NSData base64EncodedStringWithOptions:]\" js代码如下： { onEnter(log, args, state) { this.self = args[0]; }, onLeave(log, retval, state) { var before = ObjC.classes.NSString.alloc().initWithData_encoding_(this.self, 4); var after = new ObjC.Object(retval); log(`-[NSData base64EncodedStringWithOptions:]before=${before}=`); log(`-[NSData base64EncodedStringWithOptions:]after=${after}=`); } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:15:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"16、Hook Base64解码方法 $ frida-trace -UF -m \"-[NSData initWithBase64EncodedData:options:]\" -m \"-[NSData initWithBase64EncodedString:options:]\" initWithBase64EncodedData:options:方法对应的js代码如下： { onEnter(log, args, state) { this.arg2 = args[2]; }, onLeave(log, retval, state) { var before = ObjC.classes.NSString.alloc().initWithData_encoding_(this.arg2, 4); var after = ObjC.classes.NSString.alloc().initWithData_encoding_(retval, 4); log(`-[NSData initWithBase64EncodedData:]before=${before}=`); log(`-[NSData initWithBase64EncodedData:]after=${after}=`); } } initWithBase64EncodedString:options:方法对应的js代码如下： { onEnter(log, args, state) { this.arg2 = args[2]; }, onLeave(log, retval, state) { var before = new ObjC.Object(this.arg2); var after = ObjC.classes.NSString.alloc().initWithData_encoding_(retval, 4); log(`-[NSData initWithBase64EncodedString:]before=${before}=`); log(`-[NSData initWithBase64EncodedString:]after=${after}=`); } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:16:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"17、Hook加密函数AES、DES、3DES frida-trace -UF -i CCCrypt js代码如下： { onEnter: function(log, args, state) { this.op = args[0] this.alg = args[1] this.options = args[2] this.key = args[3] this.keyLength = args[4] this.iv = args[5] this.dataIn = args[6] this.dataInLength = args[7] this.dataOut = args[8] this.dataOutAvailable = args[9] this.dataOutMoved = args[10] log('CCCrypt(' + 'op: ' + this.op + '[0:加密,1:解密]' + ', ' + 'alg: ' + this.alg + '[0:AES128,1:DES,2:3DES]' + ', ' + 'options: ' + this.options + '[1:ECB,2:CBC,3:CFB]' + ', ' + 'key: ' + this.key + ', ' + 'keyLength: ' + this.keyLength + ', ' + 'iv: ' + this.iv + ', ' + 'dataIn: ' + this.dataIn + ', ' + 'inLength: ' + this.inLength + ', ' + 'dataOut: ' + this.dataOut + ', ' + 'dataOutAvailable: ' + this.dataOutAvailable + ', ' + 'dataOutMoved: ' + this.dataOutMoved + ')') if (this.op == 0) { log(\"dataIn:\") log(hexdump(ptr(this.dataIn), { length: this.dataInLength.toInt32(), header: true, ansi: true })) log(\"key: \") log(hexdump(ptr(this.key), { length: this.keyLength.toInt32(), header: true, ansi: true })) log(\"iv: \") log(hexdump(ptr(this.iv), { length: this.keyLength.toInt32(), header: true, ansi: true })) } }, onLeave: function(log, retval, state) { if (this.op == 1) { log(\"dataOut:\") log(hexdump(ptr(this.dataOut), { length: Memory.readUInt(this.dataOutMoved), header: true, ansi: true })) log(\"key: \") log(hexdump(ptr(this.key), { length: this.keyLength.toInt32(), header: true, ansi: true })) log(\"iv: \") log(hexdump(ptr(this.iv), { length: this.keyLength.toInt32(), header: true, ansi: true })) } else { log(\"dataOut:\") log(hexdump(ptr(this.dataOut), { length: Memory.readUInt(this.dataOutMoved), header: true, ansi: true })) } log(\"CCCrypt did finish\") } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:17:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"18、Hook加密函数RSA rsa加密有公钥加密和私钥加密两种方式 $ frida-trace -UF -i \"SecKeyEncrypt\" -i \"SecKeyRawSign\" SecKeyEncrypt公钥加密函数对应的js代码如下： { onEnter(log, args, state) { // 由于同一条加密信息可能会多次调用该函数，故在这输出该函数的调用栈。可根据栈信息去分析上层函数 log(`SecKeyEncrypt()=${args[2].readCString()}=`); log('SecKeyEncrypt called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); }, onLeave(log, retval, state) { } } SecKeyRawSign私钥加密函数对应的js代码如下： { onEnter(log, args, state) { log(`SecKeyRawSign()=${args[2].readCString()}=`); log('SecKeyRawSign called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:18:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"19、修改方法的入参 $ frida-trace -UF -m \"-[DetailViewController setObj:]\" js代码如下： /* * Auto-generated by Frida. Please modify to match the signature of -[DetailViewController setObj:]. * This stub is currently auto-generated from manpages when available. * * For full API reference, see: https://frida.re/docs/javascript-api/ */ { /** * Called synchronously when about to call -[DetailViewController setObj:]. * * @this {object} - Object allowing you to store state for use in onLeave. * @param {function} log - Call this function with a string to be presented to the user. * @param {array} args - Function arguments represented as an array of NativePointer objects. * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8. * It is also possible to modify arguments by assigning a NativePointer object to an element of this array. * @param {object} state - Object allowing you to keep state across function calls. * Only one JavaScript function will execute at a time, so do not worry about race-conditions. * However, do not use this to store function arguments across onEnter/onLeave, but instead * use \"this\" which is an object for keeping state local to an invocation. */ onEnter(log, args, state) { var self = new ObjC.Object(args[0]); // 当前对象 var method = args[1].readUtf8String(); // 当前方法名 log(`[${self.$className} ${method}]`); // 字符串 // var str = ObjC.classes.NSString.stringWithString_(\"hi wit!\") // 对应的oc语法：NSString *str = [NSString stringWithString:@\"hi with!\"]; // args[2] = str // 修改入参为字符串 // 数组 // var array = ObjC.classes.NSMutableArray.array(); // 对应的oc语法：NSMutableArray array = [NSMutablearray array]; // array.addObject_(\"item1\"); // 对应的oc语法：[array addObject:@\"item1\"]; // array.addObject_(\"item2\"); // 对应的oc语法：[array addObject:@\"item2\"]; // args[2] = array; // 修改入参为数组 // 字典 // var dictionary = ObjC.classes.NSMutableDictionary.dictionary(); // 对应的oc语法:NSMutableDictionary *dictionary = [NSMutableDictionary dictionary]; // dictionary.setObject_forKey_(\"value1\", \"key1\"); // 对应的oc语法：[dictionary setObject:@\"value1\" forKey:@\"key1\"] // dictionary.setObject_forKey_(\"value2\", \"key2\"); // 对应的oc语法：[dictionary setObject:@\"value2\" forKey:@\"key2\"] // args[2] = dictionary; // 修改入参为字典 // 字节 var data = ObjC.classes.NSMutableData.data(); // 对应的oc语法：NSMutableData *data = [NSMutableData data]; var str = ObjC.classes.NSString.stringWithString_(\"hi wit!\") // 获取一个字符串。 对应的oc语法：NSString *str = [NSString stringWithString:@\"hi with!\"]; var subData = str.dataUsingEncoding_(4); // 将str转换为data,编码为utf-8。对应的oc语法：NSData *subData = [str dataUsingEncoding:NSUTF8StringEncoding]; data.appendData_(subData); // 将subData添加到data。对应的oc语法：[data appendData:subData]; args[2] = data; // 修改入参字段 // 更多数据类型：https://developer.apple.com/documentation/foundation }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:19:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"20、修改方法的返回值 $ frida-trace -UF -m \"-[DetailViewController Obj]\" js代码如下： { onEnter(log, args, state) { }, onLeave(log, retval, state) { // 字符串 var str = ObjC.classes.NSString.stringWithString_(\"hi wit!\") // 对应的oc语法：NSString *str = [NSString stringWithString:@\"hi with!\"]; retval.replace(str) // 修改返回值 var after = new ObjC.Object(retval); // 打印出来是个指针时，请用该方式转换后再打印 log(`before:=${retval}=`); log(`after:=${after}=`); } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:20:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"21、打印字符串、数组、字典 $ frida-trace -UF -m \"-[DetailViewController setObj:]\" js代码如下： { onEnter(log, args, state) { var self = new ObjC.Object(args[0]); // 当前对象 var method = args[1].readUtf8String(); // 当前方法名 log(`[${self.$className} ${method}]`); var before = args[2]; // 注意，日志输出请直接使用log函数。不要使用console.log() var after = new ObjC.Object(args[2]); // 打印出来是个指针时，请用该方式转换后再打印 log(`before:=${before}=`); log(`after:=${after}=`); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:21:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"22、打印NSData $ frida-trace -UF -m \"-[DetailViewController setObj:]\" js代码如下： { onEnter(log, args, state) { var self = new ObjC.Object(args[0]); // 当前对象 var method = args[1].readUtf8String(); // 当前方法名 log(`[${self.$className} ${method}]`); var before = args[2]; // 注意，日志输出请直接使用log函数。不要使用console.log() var after = new ObjC.Object(args[2]); // 打印NSData var outValue = after.bytes().readUtf8String(after.length()) // 将data转换为string log(`before:=${before}=`); log(`after:=${outValue}=`); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"23、打印对象的所有属性和方法 $ frida-trace -UF -m \"-[DetailViewController setObj:]\" js代码如下： { onEnter(log, args, state) { var self = new ObjC.Object(args[0]); // 当前对象 var method = args[1].readUtf8String(); // 当前方法名 log(`[${self.$className} ${method}]`); var customObj = new ObjC.Object(args[2]); // 自定义对象 // 打印该对象所有属性 var ivarList = customObj.$ivars; for (key in ivarList) { log(`key${key}=${ivarList[key]}=`); } // 打印该对象所有方法 var methodList = customObj.$methods; for (var i=0; i\u003cmethodList.length; i++) { log(`method=${methodList[i]}=`); } }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:23:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"24、打印调用栈 $ frida-trace -UF -m \"+[NSURL URLWithString:]\" js代码如下： { onEnter(log, args, state) { var url = new ObjC.Object(args[2]); log(`+[NSURL URLWithString:${url}]`); log('NSURL URLWithString: called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); }, onLeave(log, retval, state) { } } ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:24:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"25、日志输出到文件 $ frida-trace -UF -m \"+[NSURL URLWithString:]\" -o run.log ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:25:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"26、更多数据类型 /** * Converts to a signed 32-bit integer. */ toInt32(): number; /** * Converts to an unsigned 32-bit integer. */ toUInt32(): number; /** * Converts to a “0x”-prefixed hexadecimal string, unless a `radix` * is specified. */ toString(radix?: number): string; /** * Converts to a JSON-serializable value. Same as `toString()`. */ toJSON(): string; /** * Returns a string containing a `Memory#scan()`-compatible match pattern for this pointer’s raw value. */ toMatchPattern(): string; readPointer(): NativePointer; readS8(): number; readU8(): number; readS16(): number; readU16(): number; readS32(): number; readU32(): number; readS64(): Int64; readU64(): UInt64; readShort(): number; readUShort(): number; readInt(): number; readUInt(): number; readLong(): number | Int64; readULong(): number | UInt64; readFloat(): number; readDouble(): number; readByteArray(length: number): ArrayBuffer | null; readCString(size?: number): string | null; readUtf8String(size?: number): string | null; readUtf16String(length?: number): string | null; 以上就是关于frida-trace在iOS端的常用命令，希望能帮助到大家。同时也建议大家阅读官方文档：https://frida.re/docs/frida-trace/ ","date":"2023-04-26","objectID":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:26:0","tags":null,"title":"Frida-trace常用命令","uri":"/frida-trace%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"appkey: 7BXHqZKLEnHTpSTk6xZNMeUFiGRQxOPoJiWtg9HAuxF0S08htQmbFkl-FInEFdOTTjDH7FFZtsO8x0Td5jsmyDqCxyfKVTG_TAQr9mgzXyEldG5Ay2sVoI_90lhsFyHvkOQ7EYgZlCrL6aKZQsba8OBa_c4HZ-YtmPvp4bjN-RE= 经过AES解密(key: 24e96202f2d6fe64 iv : 632870a7427e3bdc) =\u003e 3aff842cee6b2fea|e447_42c1b91d-031c-44e4-979c-71cdf13e7a4d|b842_cd5505fa-00b9-4a25-b990-bd10eb9e4b2b|m.yundun.waf.1 md5(42c1b91d-031c-44e4-979c-71cdf13e7a4d) =\u003e 2f4fff97d333c7aa990e374e308e0da2 aes key: xor 0x06 =\u003e (29 49 f9 91 d5 35 c1 ac 9f 08 31 48 36 88 0b a4) aes iv : (32 60 64 63 28 75 74 c6 e1 44 1c c7 2a 47 cb e4) ","date":"2023-04-26","objectID":"/%E9%98%BF%E9%87%8Cwaf3.0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/:0:0","tags":null,"title":"阿里WAF3.0逆向分析","uri":"/%E9%98%BF%E9%87%8Cwaf3.0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"}]